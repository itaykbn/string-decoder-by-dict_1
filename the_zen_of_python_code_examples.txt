1)#Beautiful is better than ugly
def collatz(num):
    if num%2 == 0:
        return num//2
    else:
        return 3 * num + 1

number = input("Enter a number: ")
while number != 1:
    number = collatz(int(number))
    print(number)

--vs--

def collatz(num):
    if num%2 == 0:
        return num//2
    
    return 3 * num + 1
------------------------------------------------------------------------------------------------------------------------
2)# Simple is better than complex
def recursion_reverse(s):
    if(len(s)==1):
        return s
    else:
        return recursion_reverse(s[1:]) + s[0]

original_string = "ABC"
print("Reversed String : ", recursion_reverse(original_string))

--vs--

my_string = “ABCD”
reversed_string = my_string[::-1]
------------------------------------------------------------------------------------------------------------------------
3)#Flat is better than nested
from spam.foo.baz import eggs

------------------------------------------------------------------------------------------------------------------------
4)#Sparse is better than dense

print('\n'.join("%i bytes = %i bits which has %i possible values." % (j, j * 8, 256 ** j - 1) for j in
                (1 << i for i in range(8))))
------------------------------------------------------------------------------------------------------------------------
5)#

------------------------------------------------------------------------------------------------------------------------
6)#
------------------------------------------------------------------------------------------------------------------------

7)#
------------------------------------------------------------------------------------------------------------------------
8) # Errors should never pass silently. Unless explicitly silenced.
try:
    import this
except ImportError:
    print('This is not available')
------------------------------------------------------------------------------------------------------------------------
9) # In the face of ambiguity, refuse the temptation to guess.
# -ambiguity
a = True
b = True
if not a and b:
    print('Hello World')
else:
    print('Bye World')
------------------------------------------------------------------------------------------------------------------------
10) # There should be one-- and preferably only one --obvious way to do it.
  ##operation do 1 + 1
good idea:
   >> print(1 + 1)

bad idea:
    class GoogleApi:
        def async send_message(self,mime_message,gmail_address, sender_address):
            #code that uses the api
            throw_callback(await async wait_for_reply() => (x) return x.value )
        def create_mime_message(self,header,body):
            #code that creates mime message
        #more functions that are required to make it work(obviously i won't write it)
        ded async wait_for_reply():
            #wait for_message_from issac newton

   import asyncio
   def main():
        google = GoogleApi()
        message = google.create_mime_message(self,"hello issac newton","please can you solve the following problem : 1+1; reply as soon as possible")
        callback = google.send_message()
        while callback is not None:
            #play luni tunes full volume

# *disclaimer the syntax is not fully correct it's just for exaggeration
------------------------------------------------------------------------------------------------------------------------
11) # Although that way may not be obvious at first unless you’re Dutch.

a = expression1 if condition else expression2
------------------------------------------------------------------------------------------------------------------------
12) #Now is better than never. Although never is often better than *right* now.

class A():
    def really_heavy_function():
        pass

def main():
    #no use for the function and that's why never is better than *right* now
    instance = A()
    print('hello')
------------------------------------------------------------------------------------------------------------------------
13) #If the implementation is hard to explain, it's a bad idea.
    #If the implementation is easy to explain, it may be a good idea.
operation count how many   spaces are in a sentece
good:
#the implementation is easy to explain that is why it's a good idea
    def main():
        sentence = input("enter sentence")
        print(check_spaces(sentence))

    def check_spaces(string):
        space_count = 0
        for char in string:
            if(char == " "):
                space_count += 1

        return space_spaces

bad:
#the implementation is hard to understand and thos is not a good idea even tho it is shorter than the previous one
    def main():
        s = input("")
        t = s.replace(" ","")
        l1 = len(s)
        l2 = len(t)
        print(l1-l2)



------------------------------------------------------------------------------------------------------------------------
14) #Namespaces are one honking great idea -- let's do more of those!
a = 2
print('id(a) =', id(a))

a = a+1
print('id(a) =', id(a))

print('id(3) =', id(3))

Output:
id(a) = 9302208
id(a) = 9302240
id(3) = 9302240
------------------------------------------------------------------------------------------------------------------------





